<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<link rel="stylesheet" href="../style.css">
<title>Review</title>
</head>
<body><h1 id='web前端开发'>Web前端开发</h1>
<h2 id='一基础知识'>一、基础知识</h2>
<h3 id='internet'>Internet</h3>
<h4 id='ip网络互联协议internet-protocol）'>IP（网络互联协议，Internet Protocol）</h4>
<ul>
<li>根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</li>
<li>IPv4</li>
<li>IPv6</li>

</ul>
<h4 id='uri统一资源标识符uniform-resource-identifier）'>URI（统一资源标识符，Uniform Resource Identifier）</h4>
<ul>
<li>URI是URL和URN的超集。</li>
<li>URI格式由URI协议名（例如http、ftp、mailto、file），⼀个冒号，和协议对应的内容所构成。</li>
<li>RFC 2396标准中定义了URI。</li>

</ul>
<h4 id='url统一资源定位符uniform-resource-locator）'>URL（统一资源定位符，Uniform Resource Locator）</h4>
<ul>
<li><p>URL是对可以从因特网上得到的<strong>资源的位置和访问方法</strong>的⼀种简洁的表示。</p>
</li>
<li><p>URL给资源的位置提供一种抽象的识别方法，并用这种方法来定位。</p>
</li>
<li><p>组成（例： <a href='http://host.company.com:80/a/b/c.html?user=Alice&amp;year=2018#p2' target='_blank' class='url'>http://host.company.com:80/a/b/c.html?user=Alice&year=2018#p2</a>）</p>
<ul>
<li>协议 (http:)：标识用于获取内容的协议；</li>
<li>主机 (//host.company.com)：要连接到的计算机的名称; </li>
<li>端口 (80)：允许多个服务器在同⼀台机器上运行; </li>
<li>路径(/a/b/c.html)：服务器用于查找内容; </li>
<li>查询字段 (?user=Alice&amp;year=2008):：提供其他参数；</li>
<li>片段标识符(p2): 单页面路由，锚点定位。</li>

</ul>
</li>
<li><p>URL相关协议：</p>
<ul>
<li>http</li>
<li>https</li>
<li>file</li>
<li>mailto</li>
<li>ftp</li>

</ul>
</li>

</ul>
<h4 id='urn统一资源名称uniform-resource-name）'>URN（统一资源名称，Uniform Resource Name）</h4>
<ul>
<li>URN是基于某名字空间通过名称指定资源的URI。</li>
<li>位置无关。</li>
<li>需要基础设施，因此未被广泛使用。</li>
<li>例：urn:ietf:rfc:2141</li>

</ul>
<p><img src="URI-URL-URN.png" alt="image-20230208173623067" style="zoom:50%;" /></p>
<h4 id='dns域名系统domain-name-system）'>DNS（域名系统，Domain Name System）</h4>
<ul>
<li><p>DNS是一个分布式数据库，本地负责控制整个数据库的部分段，客户向DNS服务器请求，得到从域名到IP地址的转化。</p>
</li>
<li><p>DNS的作用：</p>
<ul>
<li><strong>正向解析</strong>：根据主机名称（域名）查找对应的IP地址</li>
<li><strong>反向解析</strong>：根据IP地址查找对应的主机域名</li>

</ul>
</li>
<li><p>DNS域名树中的每个节点都可以通过唯⼀的<strong>全限定域名(Fully Qualified Domain Name，FQDN)</strong>来标识。FQDN给出了在DNS树中的位置。</p>
</li>
<li><p>工作过程：</p>
<ol start='' >
<li><p>客户向域名服务器发起查询请求</p>
</li>
<li><p>域名服务器本地查询结果</p>
<ol start='' >
<li>如果找到，则返回</li>
<li>如果未找到则发送到根域名服务器，根域名服务器查询根域名解析，将包含下一级域名信息的DNS地址返回给客户的域名服务器。</li>

</ol>
</li>
<li><p>客户的域名服务器根据根域名服务器解析的地址访问下一级DNS，如此递归逐级查询，直到找到位置。</p>
</li>
<li><p>客户的域名DNS服务器将查询结果返回客户机。</p>
</li>
<li><p>客户根据IP地址访问目标机。</p>
</li>

</ol>
</li>

</ul>
<h4 id='http11http2http3'>HTTP1.1，HTTP2，HTTP3</h4>
<figure><table>
<thead>
<tr><th>阶段</th><th>描述</th></tr></thead>
<tbody><tr><td>HTTP1.0</td><td>非持续连接，2个RTT时间，使用TCP链接</td></tr><tr><td>HTTP1.1</td><td><strong>支持持久连接</strong>，在相同TCP上通讯；支持流水线，可以不等反馈发送很多信息</td></tr><tr><td>HTTP2.0</td><td>支持HTTP1.1，在数据如何<strong>封装成帧</strong>上有区别，降低了request传输次数，对其多路传输</td></tr><tr><td>HTTP3.0</td><td>和HTTP2完全不同，<strong>使用UDP协议</strong>，通过重传保证效率</td></tr></tbody>
</table></figure>
<p>&nbsp;</p>
<h3 id='网络编程'>网络编程</h3>
<h4 id='网络机器人--robotstxt'>网络机器人 / Robots.txt</h4>
<ul>
<li><p>“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p>
</li>
<li><p>Robots协议是国际互联网界通行的道德规范，基于以下原则建立：</p>
<ul>
<li>搜索技术应服务于人类，同时尊重信息提供者的意愿，并维护其隐私权；</li>
<li>网站有义务保护其使用者的个人信息和隐私不被侵犯。</li>

</ul>
</li>
<li><p>robots是⼀个协议。robots.txt文件是⼀个文本文件，放置在网站根目录下。</p>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='web'>Web</h3>
<h4 id='web的发展'>Web的发展</h4>
<ol start='' >
<li>Web x.0表示的是一个阶段，是促成这个阶段的各种技术和相关产品服务的一个称呼</li>
<li>Web1.0是以<strong>编辑</strong>为特征，<strong>网站提供给用户的内容</strong>是网站编辑进行编辑处理后提供的，用户阅读网站提供的内容。这个过程是网站到用户的单向行为，比如搜狐等，<strong>静态网页为主</strong>。</li>
<li>Web2.0则是以加强了网站与用户之间的互动，<strong>网站内容基于用户提供</strong>，网站的诸多功能也由用户参与建设，实现了网站与用户<strong>双向的交流与参与</strong>，比如博客中国等。</li>
<li>web3.0是以主动性、数字最大化、多维化等为特征的，<strong>以服务为内容</strong>的第三代互联网系统。</li>

</ol>
<h4 id='web30的特点'>Web3.0的特点</h4>
<ul>
<li>语义化</li>
<li>3D</li>
<li>人工智能</li>
<li>去中心化</li>

</ul>
<h4 id='meanmongo-express-angular-node）'>MEAN（Mongo Express Angular Node）</h4>
<ul>
<li><p>是一个Javascript平台的现代Web开发框架总称</p>
<ul>
<li>MongoDB是一个使用JSON风格存储的数据库，非常适合javascript。(JSON是JS数据格式)</li>
<li>ExpressJS是一个Web应用框架，提供有帮助的组件和模块帮助建立一个网站应用。</li>
<li>AngularJS是一个前端MVC(Model View Controller)框架。</li>
<li>Node.js是一个并发异步事件驱动的Javascript服务器后端开发平台。</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<h2 id='二浏览器端'>二、浏览器端</h2>
<h3 id='html--xhtml'>HTML / XHTML</h3>
<h4 id='概念-1'>概念</h4>
<ul>
<li>HTML（超文本标记语言，Hypertext Markup Language）</li>
<li>HTML是构成 Web 世界的⼀砖⼀瓦。它定义了网页内容的含义和结构。除 HTML 以外的其它技术则通常用来描述⼀个网页的表现与展示效果（如 CSS），或功能与行为（如 JavaScript）。</li>
<li>HTML最初是⼀种应用程序标准通用标记语言(SGML)，而XHTML是SGML的⼀个更严格的子集。</li>

</ul>
<h4 id='结构'>结构：</h4>
<ul>
<li><p>HTML用于描述页面的结构</p>
</li>
<li><p>DOCTYPE</p>
<ul>
<li>文档类型</li>

</ul>
</li>
<li><p>Head</p>
<ul>
<li>元信息</li>
<li>只有<code>&lt;title&gt;</code>是必须的</li>

</ul>
</li>
<li><p>Body</p>
<ul>
<li>需要呈现的内容</li>

</ul>
</li>

</ul>
<h4 id='表现'>表现</h4>
<ul>
<li>CSS用于控制页面中元素的样式</li>

</ul>
<h4 id='行为'>行为</h4>
<ul>
<li><p>JavaScript用于响应用户操作</p>
</li>
<li><p>基本语法、常用标记</p>
<ul>
<li>见ppt</li>

</ul>
</li>

</ul>
<h4 id='html语义化'>html语义化</h4>
<ul>
<li><p>根据结构化的内容选择合适的标签</p>
</li>
<li><p>为何？</p>
<ul>
<li>有利于SEO</li>
<li>开发维护体验好</li>
<li>用户体验更好</li>
<li>更好的可访问性，方便任何设备对代码进行解析</li>

</ul>
</li>

</ul>
<h4 id='html5新特性'>html5新特性</h4>
<ul>
<li><p>新元素</p>
<p><img src="HTML5新元素.png" referrerpolicy="no-referrer" alt="image-20230209140534529"></p>
</li>
<li><p>新属性</p>
<ul>
<li>表单有新的输入类型：color，datetime，email，search，tel，url</li>

</ul>
</li>
<li><p>完全支持 CSS3</p>
</li>
<li><p>Video 和 Audio</p>
<ul>
<li>原生的音视频，不需要Javascript</li>
<li>支持各种不同的编解码器</li>

</ul>
</li>
<li><p>2D/3D 制图</p>
<ul>
<li>Canvas绘制2D图像，使用JavaScript。</li>
<li>Canvas是⼀个像素⼀个像素渲染的。在canvas中，⼀旦绘制出图形，它就会被浏览器遗忘。如果它的位置需要改变，整个场景需要重新绘制，包括可能被图形覆盖的任何对象。</li>
<li>SVG是⼀种用XML描述2D图形的语言。</li>
<li>SVG是基于XML的，这意味着SVG DOM中的每个元素都是可用的。可以为元素附加JavaScript事件处理程序。</li>
<li>在SVG中，每个绘制的形状都作为⼀个对象。如果SVG对象的属性发生了更改，浏览器可以自动重新渲染形状。</li>

</ul>
<p><img src="canvas-svg.png" referrerpolicy="no-referrer" alt="image-20230209142403579"></p>
</li>
<li><p>web存储</p>
<ul>
<li>localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</li>
<li>sessionStorage - 用于临时保存同⼀窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</li>

</ul>
</li>
<li><p>离线浏览</p>
<ul>
<li>使用HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。</li>

</ul>
</li>
<li><p>HTML5 Web SQL 数据库</p>
<ul>
<li><p>Web SQL 数据库 API 并不是 HTML5 规范的⼀部分，但是它是⼀个独立的规范，引入了⼀组使用SQL 操作客户端数据库的 APIs。</p>
</li>
<li><p>规范中定义的三个核心方法：</p>
<ol start='' >
<li>openDatabase：这个方法使用现有的数据库或者新建的数据库创建⼀个数据库对象。</li>
<li>transaction：这个方法让我们能够控制⼀个事务，以及基于这种情况执行提交或者回滚。</li>
<li>executeSql：这个方法用于执行实际的 SQL 查询。</li>

</ol>
</li>

</ul>
</li>
<li><p>HTML5 Web Workers</p>
<ul>
<li>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</li>
<li>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</li>

</ul>
</li>
<li><p>HTML5 WebSocket</p>
<p><img src="html5-websocket.png" referrerpolicy="no-referrer" alt="image-20230209144920812"></p>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='css层叠样式表cascading-style-sheets）'>CSS（层叠样式表，Cascading Style Sheets）</h3>
<ul>
<li><p>why</p>
<ul>
<li>丰富的样式定义。</li>
<li>灵活：易于使用和修改。</li>
<li>简洁、清晰。</li>
<li>多页面应用。</li>
<li>多设备兼容性：样式表允许针对多种不同类型的设备进行优化内容。</li>
<li>减少开发成本与维护成本。</li>
<li>提高页面性能。</li>

</ul>
</li>
<li><p>CSS 2.1，CSS 3新特性</p>
<ul>
<li>CSS 2.1：选择器、媒体类型、盒模型、视觉效果、产生内容、tables、分级媒体。</li>
<li>CSS 3：圆角效果、图形化边界、块阴影与文字阴影、使用RGBA实现透明效果、渐变效果、使用@Font-Face实现定制字体、多背景图、文字或图像的变形处理（旋转、缩放、倾斜、移动）、多栏布局、媒体查询等。</li>

</ul>
</li>
<li><p>CSS盒模型</p>
<p><img src="盒模型.png" referrerpolicy="no-referrer" alt="image-20230209152351485"></p>
<ul>
<li><p>最终元素的总宽度计算公式是这样的：</p>
<ul>
<li>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</li>

</ul>
</li>
<li><p>元素的总高度最终计算公式是这样的：</p>
<ul>
<li>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</li>

</ul>
</li>

</ul>
</li>
<li><p>响应式网页设计，主要手段。</p>
<ul>
<li><p>响应式网页设计(<strong>RWD，Responsive Web Design</strong>)，可以自动识别屏幕宽度、并作出相应调整网页，指页面布局(流式网格)，目标是解决设备多样化问题。</p>
</li>
<li><p>优点：</p>
<p>网站可用性大大提升、简化服务器端、易维护、只提供给搜索引擎一个入口、可支持未知设备。</p>
</li>
<li><p>缺点：</p>
<p>兼容设备导致性能低下、代码冗余(加载时间变长)，限制应用复杂性(折衷的设计方案)、用户混淆(改变了网站布局)</p>
</li>
<li><p>主要手段：</p>
<ol start='' >
<li>CSS媒体查询(不同屏幕分辨率，不同CSS规则)</li>
<li>网页头部添加viewport标签(控制窗口宽度)</li>
<li>不使用绝对大小，而使用相对大小:<code>width:20%/auto</code>、<code>px/em</code></li>
<li>流动布局</li>
<li>图片自动缩放</li>
<li>渐进增强</li>
<li>服务端组件的响应式设计</li>

</ol>
</li>

</ul>
</li>
<li><p>优先级顺序和继承关系</p>
<ul>
<li><p>相互冲突的声明将按以下顺序应用，后⼀种声明将覆盖前⼀种声明：</p>
<ol start='' >
<li>用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。</li>
<li>用户样式表中的常规声明（由<strong>用户</strong>设置的自定义样式）。</li>
<li>作者样式表中的常规声明（这些是我们 web <strong>开发人员</strong>设置的样式）。</li>
<li>作者样式表中的 !important 声明。</li>
<li>用户样式表中的 !important 声明。</li>
<li>用户代理样式表中的 !important 声明。</li>

</ol>
</li>

</ul>
</li>
<li><p>CSS选择器的优先级</p>
<ul>
<li>内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</li>

</ul>
</li>
<li><p>布局</p>
<ol start='' >
<li>圣杯布局：三列布局，中间宽度自适应，两边定宽；中间栏要在浏览器中优先展示渲染；允许任意列的高度最高实现：父元素设置padding，子元素三栏float：left, position：relative相对定位，负margin，main设置width：100%</li>
<li>双飞翼布局：功能与圣杯相同，实现方式不同双飞翼布局比圣杯布局多使用了1个div，少用⼤致4个css属性(圣杯布局container的 padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative 及对应的right和left共4个属性，；⽽双飞翼布局⼦div里用margin-left和margin-right共2 个属性，比圣杯布局思路更直接和简洁⼀点。简单说起来就是：双⻜翼布局比圣杯布局多创建了⼀个div，但不用相对布局了。</li>
<li>flex弹性布局：首先将container块设置为⼀个Flex容器：display:flex 通过order属性设置排列顺序，数字越小越靠前，通过项目属性flex-grow设置main的放⼤比例，将空余的空间用main来填充，使三个项目不满一整行；默认为0，也就是对剩余空间不做处理 通过项目属性flex-basis 设置left和right的固定宽度</li>

</ol>
</li>
<li><p>面包屑导航</p>
<ol start='' >
<li>让用户了解当前所处位置</li>
<li>体现了网站的架构层级</li>
<li>提高返回各个层级的快速入口，方便用户操作</li>
<li>有利于SEO</li>
<li>几乎没有负面影响</li>
<li>降低跳出率</li>
<li>有利于网络爬虫的爬取</li>

</ol>
</li>
<li><p>作业之主题切换</p>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='javascript'>Javascript</h3>
<h4 id='基本语法'>基本语法</h4>
<ul>
<li>可以写在body中、head中或外部文件中</li>
<li>JavaScript 拥有动态类型：这意味着相同的变量可用作不同的类型</li>
<li>大小写敏感</li>
<li>以回车或分号(;)结束语句</li>
<li>Javascript语句通过代码块的形式组合</li>

</ul>
<h4 id='严格模式'>严格模式</h4>
<ul>
<li><p>为什么使用严格模式</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少⼀些怪异行为;</li>
<li>消除代码运行的⼀些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>

</ul>
</li>
<li><p>ES6的模块自动采用严格模式，不管模块头部有没有<code>use strict</code>；</p>
</li>
<li><p>严格模式有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能使用delete prop删除变量，会报错，只能删除属性delete global[prop]</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用arguments.callee</li>
<li>不能使用arguments.caller</li>
<li>禁止this指向全局对象</li>
<li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
<li>增加了保留字(比如protected,static和interface)</li>

</ul>
</li>

</ul>
<h4 id='first-class-functions'>&quot;first-class&quot; functions</h4>
<ul>
<li>头等函数(first-class function)是指在程序设计语言中，函数被当作头等公民。</li>
<li>函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。在这样的语言中，函数的名字没有特殊含义，它们被当作具有函数类型的普通的变量对待。</li>

</ul>
<h4 id='事件驱动编程'>事件驱动编程</h4>
<ul>
<li>事件驱动编程是⼀种编程范式，其中程序流由事件决定，诸如用户操作(鼠标点击、按键)、传感器输出或来自其他程序/线程的消息。</li>
<li>事件驱动编程是图形用户界面和其他应用程序(如JavaScript web应用程序)中使用的主要范式，这些应用程序以执行特定的操作来响应用户输入为中心。</li>
<li>在事件驱动的应用程序中，通常有⼀个<strong>主循环监听事件</strong>，然后在检测到其中⼀个事件时触发回调函数。</li>

</ul>
<h4 id='面向对象'>面向对象</h4>
<ul>
<li><p>Class</p>
<pre><code class='language-javascript' lang='javascript'>//定义类
class Point {
 constructor(x, y){
     this.x = x;
     this.y = y;
 }
 // 注意函数构造的⽅式
 toString() {
     return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
 }
}

var p1 = new Point(5, 5);
p1.toString(); //&quot;(5, 5)&quot;

typeof Point // function
p1.constructor == Point //true
</code></pre>
</li>
<li><p>迭代器遍历对象的属性和方法：<code>for item in obj</code></p>
</li>
<li><p>Prototypes</p>
<ul>
<li><p>原型对象为所有对象实例所共享，因此这些实例也共享了原型函数的成员。通过内部属性绑定到原型。</p>
<pre><code class='language-javascript' lang='javascript'>function Book(title, publisher){ 
   this.title = title; 
   this.publisher = publisher; 
} 
Book.prototype.sayTitle = function(){ 
   alert(this.title); 
}; 

var book1 = new Book(&quot;High Performance JavaScript&quot;, &quot;Yahoo! Press&quot;); 
var book2 = new Book(&quot;JavaScript: The Good Parts&quot;, &quot;Yahoo! Press&quot;); 

alert(book1 instanceof Book); //true 
alert(book1 instanceof Object); //true 

book1.sayTitle(); //&quot;High Performance JavaScript&quot; 

alert(book1.toString()); //&quot;[object Object]&quot;
</code></pre>
</li>

</ul>
</li>

</ul>
<h4 id='匿名函数'>匿名函数</h4>
<ul>
<li><p>自调用</p>
<pre><code class='language-javascript' lang='javascript'>(function (str){
    //此时会输出Hello Jack
    console.log(&quot;Hello &quot; + str);
})(&#39;Jack&#39;)
</code></pre>
</li>
<li><p>事件的响应函数</p>
<pre><code class='language-javascript' lang='javascript'>//获得按钮元素
var btn=document.getElementById(&quot;btn&quot;);

//给按钮增加点击事件。
btn.onclick=function(){
    alert(&quot;当点击按钮时会执行到我哦！&quot;);
}
</code></pre>
</li>
<li><p>对象</p>
<pre><code class='language-javascript' lang='javascript'>var obj={
    name:&quot;Jack&quot;,
    age:18,
    fn:function(){
        return &quot;我叫&quot;+this.name+&quot;今年&quot;+this.age+&quot;岁了！&quot;;
    }
};
</code></pre>
</li>
<li><p>函数表达式</p>
<pre><code class='language-javascript' lang='javascript'>//将匿名函数赋值给变量fn。
var fn=function(){
    return &quot;我是一只小小小小留下，怎么飞也飞不高！&quot;
}
</code></pre>
</li>

</ul>
<h4 id='作用域作用域链闭包及其用途'>作用域、作用域链、闭包及其用途</h4>
<ul>
<li><p>作用域是当前的执行上下文，值 (en-US)和表达式在其中“可见”或可被访问，即作用域指的是有权访问的变量集合</p>
</li>
<li><p>如果⼀个变量 (en-US)或表达式不在当前的作用域中，那么它是不可用的作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。</p>
</li>
<li><p>JavaScript 的作用域：</p>
<ol start='' >
<li>全局作用域：脚本模式运行所有代码的默认作用域；</li>
<li>模块作用域：模块模式中运行代码的作用域；</li>
<li>函数作用域：由函数创建的作用域。</li>
<li>块级作用域：使用let和const声明。</li>

</ol>
</li>
<li><p>作用域链</p>
<ul>
<li><p>自由变量：当前的作用域没有定义的变量，找值则需要<strong>向父级作用域查找</strong>。</p>
</li>
<li><p>自由变量的取值要谨慎:</p>
<ul>
<li>无论函数将在哪里调用，要到创建函数的那个作用域中取</li>

</ul>
</li>

</ul>
</li>
<li><p>闭包定义</p>
<ul>
<li><strong>闭包是引用了自由变量的函数</strong></li>
<li>自由变量是作用域可以导出到外部作用域的变量</li>
<li>函数内部变量和函数参数都可以是自由变量</li>
<li>函数参数不包含this和arguments</li>

</ul>
</li>
<li><p>闭包示例</p>
<p><img src="闭包示例.png" referrerpolicy="no-referrer" alt="image-20230209180351424"></p>
</li>
<li><p>闭包应用场景</p>
<ol start='' >
<li>实现私有成员</li>
<li>保护命名空间</li>
<li>避免污染全局变量</li>
<li>变量需要长期驻留内存</li>

</ol>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='dom'>DOM</h3>
<h4 id='xhtmlxml与dom树'>XHTML/XML与DOM树</h4>
<ul>
<li><p>HTML：语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对 于传统的电脑来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 DTD 定义规则，语法要求更加严格的XHTML。</p>
</li>
<li><p>XML：最大的变化在于文档<strong>必须是良构的</strong>，所有标签必须闭合，也就是说开始标签要有相应的结束标签。另外，XHTML中所有的标签必须小写。在XHTML中，所有的参数值，包括数字，必须用双引号括起来。</p>
</li>
<li><p>DOM（文档对象模型，Document Object Model），HTML DOM是HTML的标准对象模型和编程接口。它定义了:</p>
<ul>
<li>HTML元素作为对象</li>
<li>所有HTML元素的属性</li>
<li>访问所有HTML元素的方法</li>
<li>所有HTML元素的事件</li>

</ul>
</li>
<li><p>换句话说，HTML DOM是获取、更改、添加或删除HTML元素的标准</p>
</li>

</ul>
<h4 id='dom0dom2事件流捕获目标和冒泡）'>DOM0，DOM2事件流（捕获、目标和冒泡）</h4>
<ul>
<li><p>DOM0</p>
<ul>
<li><p>通过javascript制定事件处理程序的传统方式。就是将一个函数赋值给一个事件处理属性。第四代web浏览器出现，至今为所有浏览器所支持。优点是简单且具有跨浏览器的优势。这个了解下就好，现在也比较少使用这种方式绑定事件,也不支持一些新的事件。</p>
<pre><code class='language-javascript' lang='javascript'>var btn = document.getElementById(&quot;btn&quot;);
btn.onclick = function(){
   alert(this.id);
}
// 取消绑定
btn.onclick = null;
</code></pre>
</li>
<li><p>缺点：一个事件只能对应一个处理函数</p>
</li>

</ul>
</li>
<li><p>DOM2</p>
<ul>
<li><p>DOM2事件引进了一种全新的绑定事件方法，即<strong>事件监听器</strong>，添加了一些新的事件。现在的浏览器都支持这种绑定方式，也建议使用这种绑定方式。</p>
<pre><code class='language-javascript' lang='javascript'>var btn = document.getElementById(&quot;btn&quot;);
var hander = function(){
}
// 参数：事件处理属性名称、处理函数、是否在捕获时执行事件处理函数
addEventListener(&quot;click&quot;,handler,false/true);
removeEventListener(&quot;click&quot;,handler,false/true);
</code></pre>
</li>
<li><p>DOM2级的事件规定事件流包含三个阶段</p>
<ol start='' >
<li>事件捕获</li>
<li>目标阶段</li>
<li>事件冒泡阶段</li>

</ol>
</li>
<li><p><code>addEventListener</code>添加的事件处理程序，只能通过<code>removeEventListener</code>来删除。</p>
</li>
<li><p>事件冒泡，事件开始时由最具体的元素( 文档中嵌套层次最深的那个节点)接受，然后逐级向上传播到较为不具体的节点(文档)。</p>
</li>
<li><p>事件捕获，父节点更早收到事件，而具体的节点最后收到事件。</p>
</li>
<li><p>当一个 DOM 事件触发时，它不是在触发的对象上只触发一次的，而是经历上述的三个阶段，即开始从文档的根节点流向目标对象， 然后在目标对向上被触发，之后再回溯到文档的根节点。</p>
</li>

</ul>
</li>

</ul>
<h4 id='观察者模式'>观察者模式</h4>
<ul>
<li><p>观察者模式是⼀种软件设计模式，在这种模式中，⼀个称为主题的对象维护⼀个名为观察者的依赖项列表，通常通过调用它们的⼀个方法自动通知其任何状态变化</p>
</li>
<li><p>主要用于实现分布式事件处理系统</p>
</li>
<li><p>观察者模式也是我们熟悉的模型-视图-控制器(MVC)体系结构模式中的关键部分。观察者模式在许多编程库和系统中实现，包括几乎所有的GUI工具包。</p>
<p><img src="观察者模式.png" referrerpolicy="no-referrer" alt="image-20230209191036198"></p>
</li>
<li><p>好处：</p>
<ul>
<li>主题与观察者之间的抽象耦合；</li>
<li>支持广播通信。</li>

</ul>
</li>
<li><p>注意：观察者模式会导致内存泄漏，即所谓的失效侦听器问题。</p>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='ajax不考）'>Ajax（不考）</h3>
<h4 id='ria丰富互联网应用rich-internet-applications）'>RIA（丰富互联网应用，Rich Internet Applications）</h4>
<ul>
<li><p>是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。</p>
</li>
<li><p>RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。</p>
</li>
<li><p>RIA系统的特性：</p>
<ol start='' >
<li>运行于浏览器中，不需要额外安装支持软件</li>
<li>在本地运行时，受安全沙箱全程保护。</li>

</ol>
</li>
<li><p>优点</p>
<ol start='' >
<li>无需安装</li>
<li>易于升级</li>
<li>可以通过互联网/内部网轻易获得</li>
<li>丰富的用户界面</li>
<li>更好的响应性</li>
<li>客户机/服务器平衡</li>
<li>异步通信</li>
<li>网络效率</li>

</ol>
</li>
<li><p>缺点</p>
<ol start='' >
<li>搜索引擎不够友好</li>
<li>专有的(相对于开放标准)</li>
<li>完整性丧失(RIA通常不能很好地与HTML混合)</li>
<li>软件开发的复杂性(在客户端计算机上缓存或不缓存什么?)</li>
<li>RIA体系结构打破了Web页面范式</li>

</ol>
</li>
<li><p>实现方式</p>
<ul>
<li>浏览器插件</li>
<li>Ajax</li>

</ul>
</li>

</ul>
<h4 id='同步异步通信'>同步、异步通信</h4>
<ul>
<li><p>同步</p>
<ul>
<li>用户必须等待新页面加载；</li>
<li>网页中使用的典型通信模式(点击-等待-刷新)；</li>
<li>几乎所有对新数据的更改都会导致页面刷新。</li>

</ul>
</li>
<li><p>异步</p>
<ul>
<li>用户可以在数据加载时继续与页面交互；</li>
<li>Ajax使通信模式成为可能；</li>
<li>使用新数据进行更改，但不刷新页面。</li>

</ul>
</li>

</ul>
<h4 id='ajax请求'>Ajax请求</h4>
<ul>
<li>Asynchronous JavaScript + XML（异步 JavaScript 和 XML）</li>
<li>允许只更新⼀个 HTML 页面的部分 DOM，而无须重新加载整个页面。</li>
<li>AJAX 还允许异步工作，这意味着当网页的⼀部分正试图重新加载时，您的代码可以继续运行（相比之下，同步会阻止代码继续运行，直到这部分的网页完成重新加载）。</li>

</ul>
<h4 id='ajax优缺点'>Ajax优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li>更好的交互性和响应性。</li>
<li>页面将更易于使用。</li>
<li>由于部分呈现，减少了到Web服务器的连接。</li>
<li>因为只加载更新页面所需的数据，而不是刷新整个页面，因此节省了带宽。</li>
<li>有助于减少网络流量。</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>后退和刷新按钮变得不可用。</li>
<li>收藏网页将变得不可用。</li>
<li>要求在Web浏览器上启用JavaScript。</li>
<li>网络延迟可能会破坏可用性。</li>
<li>通过AJAX加载的数据不会被任何主要搜索引擎索引。因此，使其SEO不友好。</li>

</ul>
</li>

</ul>
<h4 id='安全相关sop跨域'>安全相关，SOP，跨域</h4>
<ul>
<li><p>XSS威胁</p>
<ol start='' >
<li>跨站脚本(Cross site scripting，通常简称为XSS)是一种网站应用程序的安 全漏洞攻击，是代码注入的一种。 它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。指攻击者在网页中嵌入客户端脚本(例如JavaScript),当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.这类攻击通常包含了HTML以及用户端脚本语言。</li>
<li>AJAX无法从本地存储的网页上运行，只能在存储在Web服务器上的网页上运行</li>

</ol>
</li>
<li><p>SOP（同源策略，Same Origin Policy）</p>
<ul>
<li><p>限制浏览器可以获取的资源，只能从同源网站获取内容(除了资源文件) 同源政策规定，AJAX请求只能发给同源的网址，否则就报错。&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<ol start='' >
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM无法获得。</li>
<li>AJAX请求不能发送。</li>

</ol>
</li>

</ul>
</li>
<li><p>跨域</p>
<ul>
<li><p>当协议、子域名、主域名、端口号中任意一个不同时，都算作不同域</p>
</li>
<li><p>实现跨域的方法</p>
<ol start='' >
<li>CORS：服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制。</li>
<li>nginx：反向代理</li>
<li>Docker</li>

</ol>
</li>

</ul>
</li>

</ul>
<h4 id='数据格式'>数据格式</h4>
<ul>
<li><p>XML</p>
<ul>
<li><p>极大的互操作性</p>
</li>
<li><p>严格的格式</p>
</li>
<li><p>容易验证</p>
<p>缺点：非常详细，语法有点模糊，解析不明确</p>
</li>

</ul>
</li>
<li><p>JSON</p>
<ul>
<li>由Douglas Crockford形式化和推广，它是一种轻量级的、易于简化的数据格式，使用JavaScript对象和数组文本语法编写。</li>

</ul>
</li>
<li><p>JSON-P JSON with Padding</p>
<ol start='' >
<li>带填充的JSON</li>
<li>当使用动态脚本标记插入时，JSON数据被视为另一个JavaScript文件，并作为本机代码执行。为了实现这一点，数据必须包装在回调函数中。</li>
<li>由于JavaScript被当作本机数据来处理，因此它以本机JavaScript的速度被解析。</li>
<li>避免使用与性能无关的JSON-P有一个原因：由于JSON-P必须是可执行的JavaScript，因此任何人都可以调用它，并使用动态脚本标记插入将其包含在任何网站中。</li>
<li>不要在JSON-P中对任何敏感数据进行编码，因为您无法确保它保持私有，即使使用随机url或cookie。</li>

</ol>
</li>

</ul>
<p>&nbsp;</p>
<h2 id='三服务器端'>三、服务器端</h2>
<h3 id='nodejs'>Node.js</h3>
<h4 id='概念-2'>概念</h4>
<ul>
<li>是⼀个开源的、跨平台的Javascript运行时环境</li>
<li>服务端Javascript：开发人员可以使用 JavaScript 创建各种服务器端工具和应用程序。</li>
<li>事件驱动，异步I/O框架</li>
<li>基于v8的c++内核</li>

</ul>
<h4 id='特点'>特点</h4>
<ol start='' >
<li>MVC分离</li>
<li>现代语法和闭包使得更强大的扩展库成为可能。</li>
<li>很多语言可以交叉编译在JS中</li>
<li>Node.js通过优化可以通过Web服务传递数据，并且仅传递数据，保证交付行为良好。</li>
<li>支持JSON</li>
<li>回调机制出色，避免使用线程：单线程上异步处理，而不是传统多线程</li>
<li>适用于请求大量请求但是每个请求不需要大量计算能力的应用程序，并发问题很少。</li>

</ol>
<h4 id='应用场景'>应用场景</h4>
<ol start='' >
<li>网站（如express/koa等）</li>
<li>im即时聊天(socket.io)</li>
<li>api（移动端，pc，h5）</li>
<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>
<li>前端构建工具 (grunt/gulp/bower/webpack/fis3…)</li>
<li>写操作系统（NodeOS）</li>
<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的⼀站式开发框架ionicframework）</li>
<li>命令行工具（比如cordova、shell.js）</li>
<li>反向代理（比如anyproxy，node-http-proxy）</li>

</ol>
<h4 id='基本原理-1'>基本原理</h4>
<ol start='' >
<li><p>事件驱动模型</p>
<p>由⼀个事件收集器、⼀个事件发送器和⼀个事件处理器组成。</p>
<p><img src="nodejs事件驱动模型.png" referrerpolicy="no-referrer" alt="image-20230210085711325"></p>
</li>
<li><p>异步I/O</p>
</li>
<li><p>单线程</p>
</li>
<li><p>不惜一切代价避免同步代码，因为阻塞了时间循环，意味着很多的回调。</p>
</li>

</ol>
<h4 id='回调地狱'>回调地狱</h4>
<ul>
<li><p>事件循环</p>
<blockquote><p>There are a couple of implications of this apparently very simple and basic model. Avoid synchronous code at all costs because it blocks the event loop. Which means: callbacks, callbacks, and more callbacks.</p>
</blockquote>
</li>

</ul>
<p><img src="nodejs事件循环.png" referrerpolicy="no-referrer" alt="image-20230210090536897"></p>
<h3 id='鉴权'>鉴权</h3>
<ul>
<li><p>认证(Identification) 是指根据声明者所特有的识别信息，确认声明者的身份。</p>
</li>
<li><p>授权(Authorization)： 在信息安全领域是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便对资源的相关操作。</p>
</li>
<li><p>鉴权(Authentication) 在信息安全领域是指对于⼀个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。</p>
</li>
<li><p>权限控制(Access/Permission Control) 将可执行的操作定义为权限列表，然后判断操作是否允许/禁止。</p>
<p><img src="鉴权过程.png" referrerpolicy="no-referrer" alt="image-20230210091052278"></p>
</li>

</ul>
<h4 id='http鉴权'>HTTP鉴权</h4>
<ul>
<li>在 HTTP 中，基本认证方案（Basic Access Authentication) 是允许客户端（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。</li>
<li>几乎所有的线上网站都不会采用该方案</li>
<li>适用于内部网</li>

</ul>
<h4 id='session-cookie鉴权'>Session-Cookie鉴权</h4>
<ul>
<li><p>利用服务端的Session（会话）和浏览器（客户端）的Cookie来实现的前后端通信认证模式。</p>
</li>
<li><p>HTTP是无状态的协议，所以为了让服务器区分不同的客户端，就必须主动的去维护⼀个状态，这个状态用于告知服务端前后两个请求是否来自同⼀浏览器。而这个状态可以通过 Cookie 去实现。</p>
</li>
<li><p>Session 的抽象概念是会话，是无状态协议通信过程中，为了实现中断/继续操作，将用户和服务器之间的交互进行的⼀种抽象。</p>
</li>
<li><p>优点：</p>
<ul>
<li>Cookie 简单易用；</li>
<li>Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理；</li>
<li>只需要后端操作即可，前端可以无感等进行操作。</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>依赖 Cookie，⼀旦用户在浏览器端禁用 Cookie，那么就 GG 思密达了；</li>
<li>非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）；</li>
<li>Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；</li>
<li>对移动端的支持性不友好。</li>

</ul>
</li>

</ul>
<h4 id='token'>Token</h4>
<ul>
<li><p>Token 是⼀个令牌，客户端访问服务器时，验证通过后服务端会为其签发⼀张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。</p>
</li>
<li><p>⼀句话概括：访问资源接口（API）时所需要的资源凭证。</p>
</li>
<li><p>Token的组成：uid (用户唯⼀的身份标识) + time (当前时间的时间戳) + sign (签名，Token 的前几位以哈希算法压缩成的⼀定长度的十六进制字符串)。</p>
</li>
<li><p>认证流程图</p>
<p><img src="token认证流程.png" referrerpolicy="no-referrer" alt="image-20230210092532266"></p>
</li>
<li><p>优点：</p>
<ul>
<li>服务端无状态化、可扩展性好： Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态；</li>
<li>支持 APP 移动端设备；</li>
<li>安全性好： 有效避免 CSRF 攻击（因为不需要 Cookie）；</li>
<li>支持跨程序调用： 因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题。</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>配合：需要前后端配合处理；</li>
<li>占带宽：正常情况下比 sid 更大，消耗更多流量，挤占更多宽带；</li>
<li>性能问题：虽说验证 Token 时不用再去访问数据库或远程服务进行权限校验，但是需要对 Token 加解密等操作，所以会更耗性能；</li>
<li>有效期短：为了避免 Token 被盗用，⼀般 Token 的有效期会设置的较短，所以就有了 Refresh Token。</li>

</ul>
</li>

</ul>
<h4 id='token和session-cookie的区别'>Token和Session-Cookie的区别</h4>
<ul>
<li><p>Session-Cookie 和 Token 有很多类似的地方，但是 Token 更像是 Session-Cookie 的升级改良版。</p>
<ul>
<li>存储地不同： Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；</li>
<li>安全性不同： Session 和 Token 并不矛盾，作为身份认证， Token 安全性比Session 好，因为每⼀个请求都有签名还能防止监听以及重放攻击；</li>
<li>支持性不同： Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。</li>

</ul>
</li>

</ul>
<h4 id='jwtjson-web-token）鉴权'>JWT（JSON Web Token）鉴权</h4>
<ul>
<li><p>JWT 是 Auth0 提出的通过 对 JSON 进行加密签名来实现授权验证的方案；</p>
</li>
<li><p>就是登录成功后将相关用户信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端； 客户端在下次请求时带上这个 Token； 服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。</p>
</li>
<li><p>认证流程</p>
<p><img src="JWT认证流程.png" referrerpolicy="no-referrer" alt="image-20230210093318612"></p>
</li>
<li><p>优点：</p>
<ul>
<li>不需要在服务端保存会话信息（RESTful API 的原则之⼀就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况；</li>
<li>JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数。</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>加密问题： JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密⼀次。</li>
<li>到期问题： 由于服务器不保存 Session 状态，因此无法在使用过程中废止某个Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>

</ul>
</li>

</ul>
<h4 id='登录'>登录</h4>
<ul>
<li><p>单点登录（Single Sign On）</p>
<ul>
<li>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</li>

</ul>
</li>
<li><p>联合登录</p>
<ul>
<li>指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。</li>

</ul>
</li>
<li><p>信任登录</p>
<ul>
<li>是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。</li>

</ul>
</li>
<li><p>唯一登录</p>
<ul>
<li>指的是禁止多人同时登录同一账号，后者的登录行为，会导致前者掉线。</li>

</ul>
</li>
<li><p>扫码登录</p>
</li>
<li><p>一键登录</p>
</li>

</ul>
<p>&nbsp;</p>
<h2 id='四框架'>四、框架</h2>
<h3 id='概念-3'>概念</h3>
<ul>
<li>现代 JavaScript 框架的到来加快了打造高度动态化和交互性强的应用程序的速度。框架就是提供该如何构建应用程序的意见的库。这些意见能使应用具有可预测性和同质性。可预测性让软件能在扩展到很大规模的同时仍保持可维护性。可预测性和可维护性对于一个软件的长久健康运行是十分重要的。</li>

</ul>
<h3 id='架构演进'>架构演进</h3>
<p><img src="web架构.png" referrerpolicy="no-referrer" alt="image-20230210095447651"></p>
<h3 id='框架的优缺点'>框架的优缺点</h3>
<h4 id='优点'>优点</h4>
<ul>
<li>JS框架封装了复杂困难的代码；</li>
<li>JS框架能加快开发速度，更快完成项目；</li>
<li>JS框架让你更专注于产品内容的价值，而不是实现过程；</li>
<li>JS框架让合作更简单，大家都对基础代码有共同的理解；</li>
<li>JS框架还会强迫你练习，多实践，熟能生巧。</li>

</ul>
<h4 id='缺点'>缺点</h4>
<ul>
<li>每个项目的开发都会遇到框架文档没有说明的问题，这时候就要深入框架查找原因，这时候就需要对原生JavaScript的深度掌握。</li>
<li>新框架频繁发布，更新快速，⼀旦确定了项目的技术栈，随着时间，如何升级更新是个问题。</li>

</ul>
<p>&nbsp;</p>
<h2 id='五优化'>五、优化</h2>
<h3 id='基准测试性能分析'>基准测试/性能分析</h3>
<ol start='' >
<li><p>通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量和可对比的测试</p>
</li>
<li><p>延迟(传播、传输、处理、排队)和带宽</p>
</li>
<li><p>Web性能要点</p>
<ol start='' >
<li>延迟和带宽对Web性能的影响</li>
<li>传输协议(TCP)对HTTP的限制</li>
<li>HTTP协议自身的功能和缺陷</li>
<li>Web应用的发展趋势及性能需求</li>
<li>浏览器局限性和优化思路</li>

</ol>
</li>
<li><p>性能监控指标</p>
<ol start='' >
<li><p>FP：首次绘制，页面第一次绘制的时间点：只要出现视觉变化，无论什么。</p>
</li>
<li><p>FCP：首次内容绘制，完成对DOM中的一部分内容渲染的时间点：首次绘制来自DOM的内容。</p>
</li>
<li><p>FMP：首次有意义绘制，页面关键元素的渲染时间，由开发者自行定义。</p>
</li>
<li><p>首屏时间：应用渲染完整个屏幕的时间。</p>
</li>
<li><p>用户可交互时间：DOMReady时间</p>
</li>
<li><p>总下载时间：页面所有资源加载完成的时间，一般统计window.onload时间，也可以是异步渲染全部完成的时间。</p>
</li>
<li><p>页面所有元素夹杂时间</p>
</li>
<li><p>第一个字节加载时间</p>
</li>
<li><p>页面渲染时间：瀑布流中两个指标Start Render和msFirstPaint</p>
<ol start='' >
<li>Start Render：通过捕获页面加载的视频，实验室测量。</li>
<li>msFirstPaint：是浏览器本身报告的测量。</li>

</ol>
</li>
<li><p>DOM元素数量</p>
</li>
<li><p>自定义指标</p>
</li>

</ol>
</li>
<li><p>影响基准数据的因素</p>
<ol start='' >
<li>地理位置</li>
<li>网络问题</li>
<li>响应大小</li>
<li>代码处理</li>
<li>浏览器的行为</li>
<li>Web服务器配置</li>

</ol>
</li>

</ol>
<h3 id='基本原理-2'>基本原理</h3>
<h4 id='浏览器页面渲染机制'>浏览器页面渲染机制</h4>
<ul>
<li>DNS查询 -&gt; TCP握手 -&gt; TCP协商 -&gt; 响应</li>
<li>第一步是处理 HTML 标记并构造DOM 树。</li>
<li>第二步是处理 CSS 并构建 CSSOM 树。</li>
<li>第三步是将 DOM 和 CSSOM 组合成⼀个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。</li>
<li>第四步是在渲染树上运行布局以计算每个节点的几何体。</li>
<li>最后一步是将各个节点绘制到屏幕上。</li>

</ul>
<h3 id='优化思路技术方法'>优化思路，技术，方法</h3>
<h4 id='优化思路'>优化思路</h4>
<ul>
<li>减少DNS查找</li>
<li>重用TCP连接</li>
<li>减少HTTP重定向</li>
<li>使用CDN（内容分发网络）</li>
<li>去掉不必要的资源</li>
<li>在客户端缓存资源</li>
<li>传输压缩过的内容</li>
<li>消除不必要的请求开销</li>
<li>并行处理请求和响应</li>
<li>针对不同协议版本采取优化措施</li>

</ul>
<h4 id='浏览器优化方法'>浏览器优化方法</h4>
<ul>
<li>基于文档的优化：熟悉网络协议，了解文档、CSS 和 JavaScript 解析管道，发现和优先安排关键网络资源，尽早分派请求并取得页面，使其尽快达到可交互的状态。主要方法是优先获取资源、提前解析等</li>
<li>推测性优化：浏览器可以学习用户的导航模式，执行推测性优化，尝试预测用户的下⼀次操作。然后，预先解析DNS、预先连接可能的目标。</li>

</ul>
<h4 id='浏览器优化技术'>浏览器优化技术</h4>
<ul>
<li>资源预取和排定优先次序：文档、CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先级:初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时保存在队列中。</li>
<li>DNS预解析：对可能的域名进⾏提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停，或其他页面信号来触发。</li>
<li>TCP预连接：DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开TCP 连接。 如果猜对的话，则可以节省⼀次完整的往返(TCP 握手)时间。</li>
<li>页面预渲染：某些浏览器可以让我们提示下⼀个可能的目标，从而在隐藏的标签页中预先渲染 整个页面。这样，当用户真的触发导航时，就能立即切换过来。</li>

</ul>
<h4 id='针对http11的优化'>针对HTTP1.1的优化</h4>
<ul>
<li><p>利用HTTP管道</p>
<ul>
<li>如果你的应用可以控制客户端和服务器这两端,那么使用管道可以显著减少网络延迟。</li>

</ul>
</li>
<li><p>采用域名分区</p>
<ul>
<li>如果你的应用性能受限于默认的每来源 6 个连接,可以考虑将资源分散到多个来源。</li>

</ul>
</li>
<li><p>打包资源以减少HTTP请求</p>
<ul>
<li>拼接和精灵图等技巧有助于降低协议开销，又能达成类似管道的性能提升。</li>

</ul>
</li>
<li><p>嵌入小资源</p>
<ul>
<li>考虑直接在父文档中嵌入小资源，从而减少请求数量。</li>

</ul>
</li>

</ul>
<h4 id='针对http20的优化'>针对HTTP2.0的优化</h4>
<ul>
<li>在TCP和TLS之上实现最佳性能,同时消除不必要的网络延迟。</li>
<li>采用移动及其他经典的最佳做法: 少发数据、削减请求,根据无线网络情况调整资源供给。</li>

</ul>
<p>&nbsp;</p>
<h2 id='六tips'>六、Tips</h2>
<h3 id='异步'>异步</h3>
<h3 id='grpcrestgraphql'>gRPC、rest、GraphQL</h3>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id='七考核'>七、考核</h2>
<h3 id='基本概念'>基本概念</h3>
<ul>
<li><p>DOM3（文档对象模型，Document Object Mode）</p>
</li>
<li><p>W3C（万维网联盟，World Wide Web Consortium）</p>
</li>
<li><p>ES2015（ECMAScript2015，又称ES6）</p>
</li>
<li><p>URI（统一资源标识符，Uniform Resource Identifier)</p>
</li>
<li><p>BFC（块级格式化上下文，Block Formatting Context）</p>
</li>
<li><p>SOP（同源策略，Same Origin Policy）</p>
</li>
<li><p>Closure（闭包）</p>
</li>
<li><p>CSS Sprites（CSS图像精灵）</p>
</li>
<li><p>Session（会话）</p>
<ul>
<li>Session 的抽象概念是会话，是无状态协议通信过程中，为了实现中断/继续操作，将用户和服务器之间的交互进行的⼀种抽象。</li>

</ul>
</li>
<li><p>TLS（传输层安全协议，Transport Layer Security）</p>
<ul>
<li>为了在 HTTPS 上建立安全连接，另⼀种握手是必须的。更确切的说是 TLS 协商，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='简答题'>简答题</h3>
<ul>
<li><p>HTTP常用状态码及其含义？</p>
<ul>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>400 Bad Request</li>
<li>401 Unauthorized</li>
<li>403 forbidden</li>
<li>404 Not Found</li>
<li>500 Internal Server Error</li>

</ul>
</li>
<li><p>Javascript中，<code>0.1+0.2==0.3</code>的结果是什么，为什么？如何解决？</p>
</li>
<li><p>影响HTTP事务的TCP相关时延？</p>
<ul>
<li>TCP连接建立（三次握手）</li>
<li>TCP慢启动拥塞控制</li>
<li>Nagle的数据聚合算法</li>
<li>TCP用于承载确认的延迟确认算法</li>
<li>TIME_WAIT延迟和端口耗尽</li>

</ul>
</li>
<li><p>对<code>&lt;meta&gt;</code>标签如何理解？</p>
<ul>
<li>用于提供关于HTML文档的元数据。</li>
<li><code>&lt;meta&gt;</code>标签只能出现在<code>&lt;head&gt;</code>里。</li>
<li><code>&lt;meta&gt;</code>标签通常用于给出网页描述、关键词、文档作者、最后修改日期等信息。</li>

</ul>
</li>
<li><p>什么是优雅降级和渐进增强？</p>
<ul>
<li>优雅降级(Graceful Degradation)：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</li>
<li>渐进增强(Progressive Enhancement)：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</li>

</ul>
</li>
<li><p>什么是&quot;use strict&quot;？为何使用？</p>
<ul>
<li>Javascipt的严格模式，对于代码语法有更严格的要求。</li>
<li>消除Javascript语法的⼀些不合理、不严谨之处，减少⼀些怪异行为;</li>
<li>消除代码运行的⼀些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>

</ul>
</li>
<li><p>什么是HTTP缓存？分类？请描述基本的使用方式。</p>
<ul>
<li><p>HTTP 缓存存储与请求关联的响应，并将存储的响应复用于后续请求。</p>
</li>
<li><p>分类</p>
<ul>
<li>按照是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) </li>
<li>按照是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) </li>

</ul>
</li>
<li><p>HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。这里主要涉及两个 Header：</p>
<ol start='' >
<li>Cache-Control：设定缓存策略，是否使用缓存，超时时间是多少。</li>
<li>ETag：当前返回数据的验证令牌，可能是 Hash 值也可能是其他指纹，主要用于在下次请求的时候携带上，让服务端依此判断当前数据是否有更改。</li>

</ol>
</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='问答题'>问答题</h3>
<h4 id='前端框架有哪些选用框架的优势如何进行框架选型'>前端框架有哪些？选用框架的优势？如何进行框架选型？</h4>
<ul>
<li><p>Vue、React、Angular、Svelte</p>
</li>
<li><p>优势</p>
<ul>
<li>JS框架封装了复杂困难的代码；</li>
<li>JS框架能加快开发速度，更快完成项目；</li>
<li>JS框架让你更专注于产品内容的价值，而不是实现过程；</li>
<li>JS框架让合作更简单，大家都对基础代码有共同的理解；</li>
<li>JS框架还会强迫你练习，多实践，熟能生巧。</li>

</ul>
</li>
<li><p>选型</p>
<ul>
<li>业务场景、特点</li>
<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>
<li>熟悉程度</li>
<li>个人学习求新，企业架构求稳，无非喜好与场景而已</li>

</ul>
</li>

</ul>
<h4 id='ajax的出现解决了什么问题ajax原理及优缺点并比较不同的数据格式'>Ajax的出现解决了什么问题？Ajax原理及优缺点？并比较不同的数据格式</h4>
<ul>
<li><p>解决问题</p>
<ul>
<li>以前用户必须等待新页面加载，网页使用体验差；</li>
<li>几乎所有对新数据的更改都会导致页面刷新。</li>

</ul>
</li>
<li><p>原理</p>
<ul>
<li>Ajax提供与服务器异步通信的能力，可在web页面触发js事件中中服务器发出异步请求，如执行更新或查询数据库</li>
<li>Ajax的核心是js对象XMLHttpRequest，改对象在IE5中首次引入，使用户通过js向服务器提出请求并处理相应，不阻塞用户</li>
<li>当web服务器的相应返回时，使用js回调函数和CSS相应的更新页面的局部页面，而不是刷新整个页面</li>
<li>在页面与服务器交互的过程中不中断用户操作，用户甚至察觉不到浏览器正在与服务器进行通信</li>

</ul>
</li>
<li><p>优点</p>
<ul>
<li>更好的交互性和响应性。</li>
<li>页面将更易于使用。</li>
<li>由于部分呈现，减少了到Web服务器的连接。</li>
<li>因为只加载更新页面所需的数据，而不是刷新整个页面，因此节省了带宽。</li>
<li>有助于减少网络流量。</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>后退和刷新按钮变得不可用。</li>
<li>收藏网页将变得不可用。</li>
<li>要求在Web浏览器上启用JavaScript。</li>
<li>网络延迟可能会破坏可用性。</li>
<li>通过AJAX加载的数据不会被任何主要搜索引擎索引。因此，使其SEO不友好。</li>

</ul>
</li>
<li><p>数据格式</p>
<ul>
<li><p>JSON</p>
<ul>
<li>由Douglas Crockford形式化和推广，它是一种轻量级的、易于简化的数据格式，使用JavaScript对象和数组文本语法编写。</li>

</ul>
</li>
<li><p>JSON-P JSON with Padding</p>
<ol start='' >
<li>带填充的JSON</li>
<li>当使用动态脚本标记插入时，JSON数据被视为另一个JavaScript文件，并作为本机代码执行。为了实现这一点，数据必须包装在回调函数中。</li>
<li>由于JavaScript被当作本机数据来处理，因此它以本机JavaScript的速度被解析。</li>
<li>避免使用与性能无关的JSON-P有一个原因：由于JSON-P必须是可执行的JavaScript，因此任何人都可以调用它，并使用动态脚本标记插入将其包含在任何网站中。</li>
<li>不要在JSON-P中对任何敏感数据进行编码，因为您无法确保它保持私有，即使使用随机url或cookie。</li>

</ol>
</li>

</ul>
</li>

</ul>
<h4 id='letconstvar的区别什么是变量提升什么是暂时性死区'>let、const、var的区别？什么是变量提升？什么是暂时性死区？</h4>
<ul>
<li><p>区别可以从以下方面切入</p>
<ul>
<li><p>变量提升</p>
<ul>
<li><code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为<code>undefined</code>；</li>
<li><code>let</code> 和 <code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错。</li>

</ul>
</li>
<li><p>暂时性死区</p>
<ul>
<li><code>var</code>不存在暂时性死区；</li>
<li><code>let</code> 和 <code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>

</ul>
</li>
<li><p>块级作用域</p>
<ul>
<li><code>var</code>不存在块级作用域；</li>
<li><code>let</code> 和 <code>const</code>存在块级作用域。</li>

</ul>
</li>
<li><p>重复声明</p>
<ul>
<li><code>var</code>允许重复声明；</li>
<li><code>let</code> 和 <code>const</code>在同一作用域下不允许重复声明变量。</li>

</ul>
</li>
<li><p>修改声明的变量</p>
<ul>
<li><code>var</code>和<code>let</code>可以；</li>
<li><code>const</code>变量一旦声明，不可再改变。</li>

</ul>
</li>
<li><p>使用</p>
<ul>
<li>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code>。</li>

</ul>
</li>

</ul>
</li>
<li><p>变量提升</p>
<ul>
<li>JavaScript 变量的另⼀个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这⼀概念称为变量提升；JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。</li>
<li>但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</li>

</ul>
</li>
<li><p>暂时性死区（英temporal dead zone，简 TDZ），即代码块开始到变量声明语句完成之间的区域。</p>
</li>

</ul>
<h4 id='写出代码的运行结果'>写出代码的运行结果</h4>
<p>代码：</p>
<pre><code class='language-javascript' lang='javascript'>var value = 2021;
function fn(){
  console.log(value);
  var value = {name:&quot;Time&quot;};//变量提升
  console.log(value);
}

fn();
console.log(value);
</code></pre>
<p>输出：</p>
<pre><code>undefined
{ name: &#39;Time&#39; }
2021
</code></pre>
<p>&nbsp;</p>
<p>代码：</p>
<pre><code class='language-javascript' lang='javascript'>{
  console.log(bar)
  console.log(foo)
  var bar = 1;
  let foo = 2;
}
</code></pre>
<p>输出：</p>
<pre><code>console.log(foo)
              ^

ReferenceError: Cannot access &#39;foo&#39; before initialization
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>